<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="js/three.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/stats.min.js"></script>

    <script src='http://jeromeetienne.github.io/threex.geometricglow/examples/vendor/three.js/examples/js/libs/dat.gui.min.js'></script>
    <script src="js/threex.atmospherematerialdatgui.js"></script>


    <script src="js/threex.atmospherematerial.js"></script>
    <script src="js/simpleheat.js"></script>

</head>
<body>

<script>

    function randColor() {

        var min = 0.2;
        var max = 0.9;

        var self = this;

        function r() {

            return self.rand( min, max );
        }

        return new THREE.Color( r(), r(), r() );
    }

    var scene = new THREE.Scene();
    var WIDTH = window.innerWidth, HEIGHT = window.innerHeight;

    var camera = new THREE.PerspectiveCamera(40, window.width / window.height, 1, 100000 );
    camera.aspect = WIDTH / HEIGHT;
    camera.updateProjectionMatrix();

    camera.position.set( 100, 2000, 0 );
    camera.up = new THREE.Vector3( 0, 0, 1 );
    camera.lookAt( new THREE.Vector3( 0, 0 ,0 ) );

    window.addEventListener('resize', function () {
        var WIDTH = window.innerWidth, HEIGHT = window.innerHeight;

        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( WIDTH, HEIGHT );

        camera.aspect = WIDTH / HEIGHT;
        camera.updateProjectionMatrix();
    });

    renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setPixelRatio( window.devicePixelRatio );
    renderer.setSize(WIDTH, HEIGHT);
    renderer.sortObjects = false;

    document.body.appendChild( renderer.domElement );

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    //controls.addEventListener( 'change', render ); // add this only if there is no animation loop (requestAnimationFrame)
    controls.enableDamping = true;
    controls.dampingFactor = 0.25;
    controls.enableZoom = true;


    scene.background = new THREE.Color( 0x181818 );


    var texture = new THREE.TextureLoader().load( "res/planet4.jpg", function( t ) {

        t.minFilter = THREE.LinearFilter;

        var geom = new THREE.SphereGeometry( 64, 32, 32 );
        var material = new THREE.MeshLambertMaterial( { map: t } );
        var mesh = new THREE.Mesh( geom, material );

        mesh.rotateX( Math.random() * Math.PI );
        mesh.rotateY( Math.random() * Math.PI );
        mesh.rotateZ( Math.random() * Math.PI );

        scene.add( mesh );

        // create the mesh for the halo with AtmosphereMaterial
        var geometry	= mesh.geometry.clone();

        var scale = 1.1;
        geometry.scale( scale, scale, scale );
        var material2	= THREEx.createAtmosphereMaterial();
        var meshHalo	= new THREE.Mesh(geometry, material2 );
        scene.add( meshHalo );

        material2.uniforms.glowColor.value	= new THREE.Color('cyan');
        material2.uniforms.coeficient.value	= 1.2;
        material2.uniforms.power.value		= 5;

        // here is how to setup a datGUI for fine tuning

        var datGUI	= new dat.GUI();
        new THREEx.addAtmosphereMaterial2DatGui(material2, datGUI);

    } );

    var light = new THREE.PointLight( 0xffffff, 1 );
    light.position.copy( new THREE.Vector3( 100, 1000, 100 ) );

    scene.add( light );




    function paintScene() {

        //update();

        requestAnimationFrame(paintScene);
        renderer.render(scene, camera);
    }

    paintScene();

    // create a simpleheat object given an id or canvas reference
    var canvas = document.createElement( "canvas" );
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    var heat = simpleheat(canvas);

    var min = 10;
    var max = 20;
    var qty = Math.floor(Math.random() * (max - min)) + min;
    for ( var i = 0; i < qty; i++ ) {

        heat.add( [ canvas.width * Math.random(), canvas.height * Math.random(), Math.random()*Math.random()*Math.random() ] );
        // set data of [[x, y, value], ...] format
        //heat.data(data);
    }

    // set max data value (1 by default)
    heat.max(1);

    //heat.clear();

    // set point radius and blur radius (25 and 15 by default)
    heat.radius( 0.25 * ( canvas.width + canvas.height ) , 0.125 * ( canvas.width + canvas.height ) );

    // set gradient colors as {<stop>: '<color>'}, e.g. {0.4: 'blue', 0.65: 'lime', 1: 'red'}
    //heat.gradient( { 0.0: 'magenta', 0.8: 'black' } );// 0.35: 'blue', 0.5: 'red', 0.75: 'magenta', 1: 'black'} );
    heat.gradient( { 0.0: randColor().getStyle(), 0.8: randColor().getStyle() } );// 0.35: 'blue', 0.5: 'red', 0.75: 'magenta', 1: 'black'} );

    // call in case Canvas size changed
    //heat.resize();
    // draw the heatmap with optional minimum point opacity (0.05 by default)
    heat.draw( 0.015 );

    var texHeat = new THREE.Texture( canvas );
    texHeat.needsUpdate = true;

    var matHeat = new THREE.SpriteMaterial( {

        //color: 0x555599,
        blending: THREE.AdditiveBlending,
        depthWrite: true,
        map: texHeat
    } );


    var sprite = new THREE.Sprite( matHeat );
    sprite.position.set( 0, -1000, 1 );
    sprite.scale.set( canvas.width * 2, canvas.height * 2, 1 );

    /*var halfHeight = sprite.position.distanceTo(camera.position) / Math.tan( camera.fov/2 * Math.PI / 180 );
    var yscale = halfHeight * 2;
    var xscale = yscale * texHeat.image.width / texHeat.image.height;//, or the other way round y-scale = x-scale * textureHeight / textureWidth.
    sprite.scale.set( xscale, yscale, 1 );*/

    scene.add( sprite );

</script>


</body>
</html>