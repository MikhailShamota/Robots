<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="js/three.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/stats.min.js"></script>

    <script src='http://jeromeetienne.github.io/threex.geometricglow/examples/vendor/three.js/examples/js/libs/dat.gui.min.js'></script>
    <script src="js/threex.atmospherematerialdatgui.js"></script>


    <script src="js/threex.atmospherematerial.js"></script>
    <script src="js/simpleheat.js"></script>

</head>
<body>

<script>

    function randColor( light ) {

        function r( min, max ) {

            return Math.random() * (max - min) + min;
        }

        return new THREE.Color().setHSL( r(0,1), r(0.35,0.43), r(0.3,0.4) );
    }

    var scene = new THREE.Scene();
    var WIDTH = window.innerWidth, HEIGHT = window.innerHeight;

    var camera = new THREE.PerspectiveCamera(40, window.width / window.height, 1, 100000 );
    camera.aspect = WIDTH / HEIGHT;
    camera.updateProjectionMatrix();

    camera.position.set( 100, 2000, 0 );
    camera.up = new THREE.Vector3( 0, 0, 1 );
    camera.lookAt( new THREE.Vector3( 0, 0 ,0 ) );

    window.addEventListener('resize', function () {
        var WIDTH = window.innerWidth, HEIGHT = window.innerHeight;

        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( WIDTH, HEIGHT );

        camera.aspect = WIDTH / HEIGHT;
        camera.updateProjectionMatrix();
    });

    renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setPixelRatio( window.devicePixelRatio );
    renderer.setSize(WIDTH, HEIGHT);
    renderer.sortObjects = false;

    document.body.appendChild( renderer.domElement );

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    //controls.addEventListener( 'change', render ); // add this only if there is no animation loop (requestAnimationFrame)
    controls.enableDamping = true;
    controls.dampingFactor = 0.25;
    controls.enableZoom = true;


    scene.background = new THREE.Color( randColor() );


    var texture = new THREE.TextureLoader().load( "res/planet4.jpg", function( t ) {

        t.minFilter = THREE.LinearFilter;

        var geom = new THREE.SphereGeometry( 64, 32, 32 );
        var material = new THREE.MeshLambertMaterial( { map: t } );
        var mesh = new THREE.Mesh( geom, material );

        mesh.rotateX( Math.random() * Math.PI );
        mesh.rotateY( Math.random() * Math.PI );
        mesh.rotateZ( Math.random() * Math.PI );

        scene.add( mesh );

        // create the mesh for the halo with AtmosphereMaterial
        var geometry	= mesh.geometry.clone();

        var scale = 1.1;
        geometry.scale( scale, scale, scale );
        var material2	= THREEx.createAtmosphereMaterial();
        var meshHalo	= new THREE.Mesh(geometry, material2 );
        scene.add( meshHalo );

        material2.uniforms.glowColor.value	= new THREE.Color('cyan');
        material2.uniforms.coeficient.value	= 1.2;
        material2.uniforms.power.value		= 5;

        // here is how to setup a datGUI for fine tuning

        var datGUI	= new dat.GUI();
        new THREEx.addAtmosphereMaterial2DatGui(material2, datGUI);

    } );

    var light = new THREE.PointLight( 0xffffff, 1 );
    light.position.copy( new THREE.Vector3( 100, 1000, 100 ) );

    scene.add( light );




    function paintScene() {

        //update();

        requestAnimationFrame(paintScene);
        renderer.render(scene, camera);
    }

    paintScene();

    function spectre( x, min, max ) {

        return x * (max - min) + min;
    }

    function clamp(value, min, max) {

        if (value < min) {
            return min;
        }
        else if (value > max) {
            return max;
        }

        return value;
    }

    function getSprite( gradient ) {

        var canvas = document.createElement("canvas");
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;


        var heat = simpleheat(canvas);
        heat.clear();

        var heatAreaMarginWidth = -canvas.width * 0.2;
        var heatAreaMarginHeight = -canvas.height * 0.2;
        var minQty = 50;
        var maxQty = 200;
        var qty = Math.floor( spectre( Math.random(), minQty, maxQty ) );
        var maxOpacity = spectre( Math.random() * Math.random(), 0.75, 0.1 );
        for (var i = 0; i < qty; i++) {

            var sparkForce = Math.random();//0..1
            heat.add([
                spectre( Math.random(), 0, canvas.width ),
                spectre( Math.random(), 0, canvas.height ),
                spectre( sparkForce, 0.04, 0.1 ) * maxOpacity,//light
                spectre( sparkForce, 90, 600 )//size
            ]);
            // set data of [[x, y, value], ...] format
            //heat.data(data);
        }

        // set max data value (1 by default)
        heat.max(1);

        //heat.clear();

        // set point radius and blur radius (25 and 15 by default)
        heat.radius(1000, 0.27525 * ( canvas.width + canvas.height ));

        // set gradient colors as {<stop>: '<color>'}, e.g. {0.4: 'blue', 0.65: 'lime', 1: 'red'}
        //heat.gradient( { 0.0: 'magenta', 0.8: 'black' } );// 0.35: 'blue', 0.5: 'red', 0.75: 'magenta', 1: 'black'} );
        //heat.gradient({0.0: randColor().getStyle(), 0.8: randColor().getStyle()});// 0.35: 'blue', 0.5: 'red', 0.75: 'magenta', 1: 'black'} );
        heat.gradient( gradient );// 0.35: 'blue', 0.5: 'red', 0.75: 'magenta', 1: 'black'} );

        // call in case Canvas size changed
        //heat.resize();
        // draw the heatmap with optional minimum point opacity (0.05 by default)
        heat.draw( Math.random() * 0.01 );

        var texHeat = new THREE.Texture(canvas);
        texHeat.needsUpdate = true;

        var matHeat = new THREE.SpriteMaterial({

            blending: THREE.AdditiveBlending,
            depthWrite: true,
            map: texHeat
        });


        var sprite = new THREE.Sprite(matHeat);
        sprite.position.set(0, -1000, 1);
        sprite.scale.set(canvas.width * 2, canvas.height * 2, 1);

        return sprite;
    }
    /*var halfHeight = sprite.position.distanceTo(camera.position) / Math.tan( camera.fov/2 * Math.PI / 180 );
    var yscale = halfHeight * 2;
    var xscale = yscale * texHeat.image.width / texHeat.image.height;//, or the other way round y-scale = x-scale * textureHeight / textureWidth.
    sprite.scale.set( xscale, yscale, 1 );*/

    //scene.add( getSprite( { 0.8: randColor().getStyle(), 0.5: randColor().getStyle(), 0.2:'black' } ) );
    var c1 = randColor().getStyle();
    var c2 = randColor().getStyle();
    scene.add( getSprite( {
        1.0: 'white',
        0.8: c2,
        0.3: c1
    } ) );


</script>


</body>
</html>